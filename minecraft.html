<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 2px rgba(0,0,0,0.8);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 3px solid #444;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        .inventory-slot.active {
            border-color: white;
            background: rgba(255,255,255,0.2);
        }
        #instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>FPS: <span id="fps">0</span></div>
            <div>Position: <span id="position">0, 0, 0</span></div>
        </div>
        <div id="crosshair"></div>
        <div id="inventory">
            <div class="inventory-slot active" data-block="grass">ðŸŸ©</div>
            <div class="inventory-slot" data-block="stone">ðŸŸ«</div>
            <div class="inventory-slot" data-block="wood">ðŸŸ¤</div>
            <div class="inventory-slot" data-block="dirt">ðŸŸ¤</div>
            <div class="inventory-slot" data-block="sand">ðŸŸ¨</div>
        </div>
        <div id="instructions">
            WASD: Move<br>
            Mouse: Look<br>
            Left Click: Break<br>
            Right Click: Place<br>
            1-5: Select Block<br>
            Space: Jump<br>
            Click to start!
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class MinecraftGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.world = {};
                this.blockTypes = {
                    grass: { color: 0x7CB342, emoji: 'ðŸŸ©' },
                    stone: { color: 0x666666, emoji: 'ðŸŸ«' },
                    wood: { color: 0x8D6E63, emoji: 'ðŸŸ¤' },
                    dirt: { color: 0x5D4037, emoji: 'ðŸŸ¤' },
                    sand: { color: 0xFFD54F, emoji: 'ðŸŸ¨' }
                };
                this.selectedBlock = 'grass';
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.velocity = new THREE.Vector3();
                this.isGrounded = false;
                this.raycaster = new THREE.Raycaster();
                this.pointer = new THREE.Vector2();
                this.isPointerLocked = false;
                
                this.init();
            }

            init() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);

                // Setup camera
                this.camera.position.set(0, 5, 0);

                // Setup lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Generate initial world
                this.generateWorld();

                // Setup controls
                this.setupControls();

                // Start game loop
                this.animate();
            }

            generateWorld() {
                const worldSize = 16;
                for (let x = -worldSize; x < worldSize; x++) {
                    for (let z = -worldSize; z < worldSize; z++) {
                        const height = Math.floor(Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3) + 2;
                        for (let y = 0; y <= height; y++) {
                            let blockType = 'stone';
                            if (y === height) blockType = 'grass';
                            else if (y === height - 1) blockType = 'dirt';
                            
                            this.placeBlock(x, y, z, blockType);
                        }
                    }
                }

                // Add some trees
                for (let i = 0; i < 10; i++) {
                    const x = Math.floor(Math.random() * 20) - 10;
                    const z = Math.floor(Math.random() * 20) - 10;
                    const groundY = this.getGroundLevel(x, z);
                    if (groundY >= 0) {
                        // Tree trunk
                        for (let y = groundY + 1; y <= groundY + 3; y++) {
                            this.placeBlock(x, y, z, 'wood');
                        }
                        // Tree leaves
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                for (let dy = 0; dy <= 1; dy++) {
                                    if (Math.random() > 0.3) {
                                        this.placeBlock(x + dx, groundY + 4 + dy, z + dz, 'grass');
                                    }
                                }
                            }
                        }
                    }
                }
            }

            getGroundLevel(x, z) {
                for (let y = 10; y >= 0; y--) {
                    if (this.getBlock(x, y, z)) {
                        return y;
                    }
                }
                return -1;
            }

            placeBlock(x, y, z, type) {
                const key = `${x},${y},${z}`;
                if (this.world[key]) {
                    this.scene.remove(this.world[key]);
                }

                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: this.blockTypes[type].color });
                const cube = new THREE.Mesh(geometry, material);
                
                cube.position.set(x, y, z);
                cube.castShadow = true;
                cube.receiveShadow = true;
                cube.userData = { type, x, y, z };
                
                this.scene.add(cube);
                this.world[key] = cube;
            }

            removeBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                if (this.world[key]) {
                    this.scene.remove(this.world[key]);
                    delete this.world[key];
                }
            }

            getBlock(x, y, z) {
                const key = `${x},${y},${z}`;
                return this.world[key];
            }

            setupControls() {
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    // Number keys for block selection
                    if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                        const blockTypes = Object.keys(this.blockTypes);
                        const index = parseInt(e.code.charAt(5)) - 1;
                        if (blockTypes[index]) {
                            this.selectedBlock = blockTypes[index];
                            this.updateInventoryUI();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse events
                document.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouse.x -= e.movementX * 0.002; // Dibalik agar sesuai dengan arah mouse
                        this.mouse.y -= e.movementY * 0.002; // Dibalik agar sesuai dengan arah mouse
                        this.mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.mouse.y));
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    if (this.isPointerLocked) {
                        if (e.button === 0) { // Left click - break block
                            this.breakBlock();
                        } else if (e.button === 2) { // Right click - place block
                            this.placeBlockAtCursor();
                        }
                    }
                });

                document.addEventListener('contextmenu', (e) => e.preventDefault());

                // Inventory clicks
                document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
                    slot.addEventListener('click', () => {
                        this.selectedBlock = slot.dataset.block;
                        this.updateInventoryUI();
                    });
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            updateInventoryUI() {
                document.querySelectorAll('.inventory-slot').forEach(slot => {
                    slot.classList.toggle('active', slot.dataset.block === this.selectedBlock);
                });
            }

            breakBlock() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children.filter(obj => obj.userData.type));
                
                if (intersects.length > 0) {
                    const block = intersects[0].object;
                    this.removeBlock(block.userData.x, block.userData.y, block.userData.z);
                }
            }

            placeBlockAtCursor() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children.filter(obj => obj.userData.type));
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const face = intersect.face;
                    const block = intersect.object;
                    
                    // Calculate new block position based on face normal
                    const newPos = new THREE.Vector3();
                    newPos.copy(intersect.point);
                    newPos.add(face.normal.multiplyScalar(0.5));
                    
                    const x = Math.round(newPos.x);
                    const y = Math.round(newPos.y);
                    const z = Math.round(newPos.z);
                    
                    // Don't place block where player is standing
                    const playerPos = this.camera.position;
                    const playerBlockX = Math.floor(playerPos.x);
                    const playerBlockY = Math.floor(playerPos.y);
                    const playerBlockZ = Math.floor(playerPos.z);
                    
                    if (!(x === playerBlockX && (y === playerBlockY || y === playerBlockY - 1) && z === playerBlockZ)) {
                        this.placeBlock(x, y, z, this.selectedBlock);
                    }
                }
            }

            updatePlayer() {
                const speed = 0.1;
                const jumpPower = 0.2;
                
                // Movement
                const direction = new THREE.Vector3();
                
                if (this.keys['KeyW']) direction.z -= 1;
                if (this.keys['KeyS']) direction.z += 1;
                if (this.keys['KeyA']) direction.x -= 1;
                if (this.keys['KeyD']) direction.x += 1;
                
                // Apply camera rotation to movement direction
                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mouse.x);
                direction.normalize();
                direction.multiplyScalar(speed);
                
                // Apply movement
                this.camera.position.add(direction);
                
                // Jumping
                if (this.keys['Space'] && this.isGrounded) {
                    this.velocity.y = jumpPower;
                    this.isGrounded = false;
                }
                
                // Gravity
                this.velocity.y -= 0.01;
                this.camera.position.y += this.velocity.y;
                
                // Ground collision
                const groundLevel = this.getGroundLevel(
                    Math.floor(this.camera.position.x),
                    Math.floor(this.camera.position.z)
                ) + 2.8;
                
                if (this.camera.position.y <= groundLevel) {
                    this.camera.position.y = groundLevel;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                }
                
                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.x = this.mouse.y;
                this.camera.rotation.y = this.mouse.x;
            }

            updateUI() {
                const pos = this.camera.position;
                document.getElementById('position').textContent = 
                    `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updatePlayer();
                this.updateUI();
                this.renderer.render(this.scene, this.camera);
                
                // FPS counter
                const now = Date.now();
                if (this.lastTime) {
                    const fps = Math.round(1000 / (now - this.lastTime));
                    document.getElementById('fps').textContent = fps;
                }
                this.lastTime = now;
            }
        }

        // Start the game
        const game = new MinecraftGame();
    </script>
</body>
</html>